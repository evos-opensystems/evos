import numpy as np
import os
import sys
import time
from numpy import linalg as LA
from scipy.linalg import expm
import psutil
import pyten as ptn
##import evos.src.observables.observables as observables

class MPSQuantumJumps():
    """_summary_
    """
    def __init__(self, n_sites: int, lat: ptn.mp.lat, H: ptn.mp.MPO, lindbl_op_list: list):
        """Computes the effective Hamiltonian and splits in into a Hermitian and and AntiHermitian part. Adds lindblad operators,
        effective hamiltonian and n_sites to instance variables.
        Similar init to that of the Lindblad class.

        Parameters
        ----------
        n_sites : int
            number of lattice sites
        H : ptn.mp.MPO
            Hamiltonian (the hermitian, not the effective one)
        lindbl_op_list : list
            list with the lindblad operators
        """
        
        self.n_sites = n_sites
        self.lindbl_op_list = lindbl_op_list
        self.lat = lat
        H_eff = H.copy() #compute effective Hamiltonian H_eff = H - i/2 \sum_m L^\dagger _m * L_m 
        for i in range( len(lindbl_op_list) ):
            H_eff += - 0.5j * lindbl_op_list[i] * ptn.mp.dot( lat.get("I"), lindbl_op_list[i].copy() )  #NOTE: in pyten order of operators is reversed
            H_eff.truncate()
        
        H_eff_dag = ptn.mp.dot(lat.get("I"), H_eff.copy())
        H_s = 0.5 * ( H_eff.copy() + H_eff_dag.copy() ) #herm part
        H_a = 0.5 * ( H_eff.copy() - H_eff_dag.copy() ) #antiherm part
        H_as = -1j * H_a #make it herm
    
        self.H_eff = H_eff
        self.H_s = H_s
        self.H_as = H_as
        
        
    def bisection(self, f, a, b, tol, max_iterations, n_iterations): 
        #always call with n_iterations=0 (but it cannot be set to keyword argument)!
        # approximates a root, R, of f bounded 
        # by a and b to within tolerance 
        # | f(m) | < tol with m the midpoint 
        # between a and b Recursive implementation
        #print('entered bisection method')
        
        # check if a and b bound a root
        #if np.sign(f(a)) == np.sign(f(b)):
            #FIXME: understand why this exception was raised when r1 and delta_p where very close to one another
            #raise Exception(
            #"The scalars a and b do not bound a root. n_iterations = {}".format(n_iterations))
            
        
        # get midpoint
        m = (a + b)/2
        
        if np.abs(f(m)) < tol: #or n_iterations == max_iterations:
            #print('entered condition 1')
            # stopping condition, report m as root
            #print('Converged up to {} after {} iterations'.format(tol, n_iterations))
            return m, n_iterations, 0 #counter for uncoverged times + 0
        
        elif  n_iterations == max_iterations:
            #print('entered condition 2')
            #print('Did not converge up to {} after {} iterations'.format(tol, n_iterations))
            return m, n_iterations, 1 #counter for uncoverged times + 1
            
        elif np.sign(f(a)) == np.sign(f(m)):
            #print('entered condition 3')
            # case where m is an improvement on a. 
            # Make recursive call with a = m
            return self.bisection(f, m, b, tol, max_iterations,n_iterations+1)
        
        elif np.sign(f(b)) == np.sign(f(m)):
            #print('entered condition 4')
            # case where m is an improvement on b. 
            # Make recursive call with b = m
            return self.bisection(f, a, m, tol, max_iterations, n_iterations+1)

        else:
            #print('mattia: unknown error')
            return m, n_iterations, 1 #counter for uncoverged times + 1
    
        
    def norm_decrease(self, psi: ptn.mp.MPS, r1: float, dt: float)-> float :
        """Compute difference between 1 - norm^2 decrese generated by ev with H_eff (to first order) up to t and the random number r1"""
        #return lambda dt : 1. - LA.norm( np.dot( expm( -1j*dt*H_eff ), psi_t.copy() ) )**2 - r1
        psi, inutile = ptn.mp.apply_op_fit( psi.copy(), self.lat.get('I') - 1j * dt * self.H_eff ,  ptn.Truncation(1e-8,2000,2000,1e-10), 1e-8, 12, 4)
        return lambda dt : 1. - psi.norm() ** 2 -r1
    
    
    def select_jump_operator(self, psi: ptn.mp.MPS, r2: float, threshold :float, weight: float, maxStates: int) -> tuple:
        """Selects which lindblad operator to apply for a jump out of the 'lindbl_op_list', given the state 'psi' and the pseudo-random number 'r2'

        Parameters
        ----------
        psi : ptn.mp.MPS
            state on which a jump operator need to be applied
        r2 : float
            pseudo-random number drawn from uniform distribution between 0 and 1.

        Returns
        -------
        tuple[ptn.mp.MPS, int]
            returns the state after the jump application and the index (integer) indicating which operator out of the input list hast been applied.
            The second output is only for debugging.
        """
        #cast all lindblad operators from numpy matrix to numpy array to be able to use np.dot!
        
        states_after_jump_operator_application_list = []
        # norm = psi.norm() #needed to rescale ptn.Truncation().scaled(norm)  maxStates=10
        # threshold *= norm #NOTE: it's okay to overwrite these 3 parameters since they are reinitialized when the next jump occurs 
        # weight *= norm ** 2
        # maxStates = int(maxStates * norm ** 2 )
        for jump_op in self.lindbl_op_list:
            ###threshold_MPS = tdvp_trunc_threshold * state1.norm()  weight_MPS = tdvp_trunc_weight * state1.norm()**2 FIXME: scale the truncation!
            #states_after_jump_operator_application, inutile = ptn.mp.apply_op_fit( psi.copy(), jump_op,  ptn.Truncation(maxStates=10).scaled(norm), 1e-8, 12, 4) #ptn.Truncation(1e-8,2000,2000,1e-10)
            states_after_jump_operator_application, inutile = ptn.mp.apply_op_fit( psi.copy(), jump_op, ptn.Truncation( ), 1e-8, 12, 4) #,  ptn.Truncation( threshold, maxStates, maxStates, weight )
            ####
            # states_after_jump_operator_application = psi.copy()  #FIXME test wheter with exact application mps and ed agree!
            # ptn.mp.apply_op_naive( states_after_jump_operator_application, jump_op)
            ####
            states_after_jump_operator_application_list.append( states_after_jump_operator_application )

        norms_after_jump_operator_application_vector_squared = np.zeros( len( states_after_jump_operator_application_list ) )
        for i in range( len( states_after_jump_operator_application_list ) ):
            norms_after_jump_operator_application_vector_squared[i] = states_after_jump_operator_application_list[i].norm() ** 2

        tot_norm = sum(norms_after_jump_operator_application_vector_squared)
        #FIXME: check whether this is correct!!
        # if tot_norm == 0:
        #     return psi, None #which_jump_op=none
        #     return states_after_jump_operator_application[0], None #WORKS ONLY IN THE CASE OF SINGLE LINDBLAD OP!
        
        #Normalize the probabilities
        norms_after_jump_operator_application_vector_squared /= tot_norm

        #make array with intervals proportional to probability of one jump occurring
        intervals = np.zeros(len(states_after_jump_operator_application_list)+1)
        intervals[1] = norms_after_jump_operator_application_vector_squared[0]
        for i in range( 2, len(intervals ) ):
            intervals[i] = intervals[i-1] + norms_after_jump_operator_application_vector_squared[i-1]
    
        #choose and apply jump operator 
        for i in range( 1,len( intervals ) ):
            if r2 >= intervals[i-1] and r2 <= intervals[i]:
                #print(r2,"belongs to interval ",i, "that goes from ",intervals[i-1],"to",intervals[i])
                psi = states_after_jump_operator_application_list[i-1]
                which_jump_op = i-1
                break
        print('After jump, norm(psi) = {}'.format( psi.norm() ) )    
        print('finished "select_jump_operator" method')    
        psi.normalise()
        print('The state after the jump has then be normalised')    
        return psi, which_jump_op      

    
    def trotterized_nonherm_tdvp_step(self, psi: ptn.mp.MPS, dt):
        """ FIXME: not working!!
            Perform one trotterized time-evolution step by doing one real timestep with Hs = 0.5(H_eff + H_eff_dag)
           and one imeginary timestep with with Hqs = 0.5j(H_eff - H_eff_dag)
        """
        #real time-evolution step
        #self.conf_tdvp.dt = dt #unneeded?
        self.conf_tdvp.maxt = dt 
        
        worker = ptn.mp.tdvp.PTDVP( psi.copy(),[self.H_s.copy()], self.conf_tdvp.copy() )
        worker_do_stepList = worker.do_step()
        psi = worker.get_psi(False)
        
        #imaginary time-evolution step
        self.conf_tdvp.dt = 1j * dt
        self.conf_tdvp.maxt = 1j * dt
        
        worker = ptn.mp.tdvp.PTDVP( psi.copy(), [self.H_as.copy()], self.conf_tdvp.copy() )
        worker_do_stepList = worker.do_step()
        psi = worker.get_psi(False)
        
        return psi
        
    def exact_step_with_nonherm_tdvp_solver(self, psi: ptn.mp.MPS):
        """_summary_
        """
        self.conf_tdvp.exp_conf.mode = 'N'
        self.conf_tdvp.exp_conf.submode = 'a'
        self.conf_tdvp.exp_conf.minIter = 20

        worker = ptn.mp.tdvp.PTDVP( psi.copy(),[self.H_eff.copy()], self.conf_tdvp.copy() )
        worker_do_stepList = worker.do_step()
        psi = worker.get_psi(False)
        
        return psi
        
    def quantum_jump_single_trajectory_time_evolution(self, psi_t: ptn.mp.MPS, conf_tdvp, t_max: float, dt: float, tol:int, max_iterations:int, trajectory: int, obsdict: dict, threshold: float, weight: float, maxStates: int):
        """Compute the time-evolution via the quantum jumps method for a single trajectory. Two arrays r1 and r2 of random numbers are used 
        first to check if a jump needs to be applied if yes then which operator to use.

        Parameters
        ----------
        psi_t : ptn.mp.MPS
            initial state to be evolved
        t_max : float
            maximal evolution time
        dt : float
            timestep
        trajectory : int
            integer labelling the trajectory
        obsdict: 
            instance of the class  'evos.src.observables.observables.Observables()'
        """
        
        self.conf_tdvp = conf_tdvp
        #non-hermitian tdvp #FIXME: specify this before
        self.conf_tdvp.exp_conf.mode = 'N'  #FIXME: specify this before
        self.conf_tdvp.exp_conf.submode = 'a' #FIXME: specify this before
        #self.conf_tdvp.exp_conf.minIter = 20 #FIXME: specify this before
        worker = ptn.mp.tdvp.PTDVP( psi_t.copy(),[self.H_eff.copy()], self.conf_tdvp.copy() )
        
        os.mkdir( str( trajectory ) ) #create directory in which to run trajectory
        os.chdir( str( trajectory ) ) #change to it
        n_timesteps = int(t_max/dt) #NOTE: read from instance or compute elsewhere
        jump_counter = 0 #debugging
        jump_time_list = [] #debugging
        which_jump_op_list = [] #debugging
        r2_atjump_list = [] #debugging
        
        np.random.seed( trajectory + 1 ) #set seed for r1 this trajectory
        r1_array = np.random.uniform( 0, 1, n_timesteps ) #generate random numbers array r1
        #print('r1_array: ',r1_array)
        np.random.seed( int( ( trajectory + 1 ) / dt ) ) #set seed for r2 this trajectory
        r2_array = np.random.uniform( 0, 1, n_timesteps )  #generate random numbers array r2 to be used by method 'select_jump_operator()'

        #Compute observables with initial state
        obsdict.compute_all_observables_at_one_timestep(psi_t, 0)        
        #loop over timesteps
        memory_usage = []
        r1 = r1_array[0] #NOTE: initialize random number
        switched_to_1tdvp = False
        
        for i in range( n_timesteps ):
            '''
            print('computing timestep ',i) #debugging
            print('norm(psi_t) = {}'.format( psi_t.norm() ) )
            #switch to single-site tdvp when maximal bond dim is reached
            if i % 5 == 0 and switched_to_1tdvp == False:
                try: #NOTE this switching to 1tdvp works only if the bond dimension is saved in an observable 'bdim_mat'
                    bdim_i = np.loadtxt('bdim_mat')[:,i]
                    bdim_i_av = np.sum(bdim_i)/len(bdim_i)
                    #print('bdim_i_av = ',bdim_i_av)
                    # if bdim_i_av / self.conf_tdvp.trunc.maxStates >= 0.95: #FIXME: is this a good threshold?
                    #     print('switched to 1tdvp')
                    #     self.conf_tdvp.mode = ptn.tdvp.Mode.Single
                    #     switched_to_1tdvp = True
                except:
                    pass    
                    
            '''
        
            self.conf_tdvp.trunc.threshold = threshold * psi_t.norm()
            self.conf_tdvp.trunc.weight = weight * psi_t.norm() **2 
            self.conf_tdvp.trunc.maxStates = int( maxStates * psi_t.norm() **2 )
            
            worker = ptn.mp.tdvp.PTDVP( psi_t.copy(),[self.H_eff.copy()], self.conf_tdvp.copy() ) #NOTE: REINITIALIZE WORKER TO SCALE TRUNCATION WITH NORM
            # threshold_MPS *=  state1.norm()
            # weight_MPS *=  state1.norm()**2
            process = psutil.Process(os.getpid())
            memory_usage.append( process.memory_info().rss ) # in bytes
            np.savetxt('memory_usage', memory_usage)
            
            #psi_1 = self.trotterized_nonherm_tdvp_step(psi_t, dt) #FIXME: not working  #psi_1 = np.dot( U, psi_t.copy() )  
            #psi_1 = self.exact_step_with_nonherm_tdvp_solver(psi_t) 
            worker_do_stepList = worker.do_step()
            psi_1 = worker.get_psi(False)
            
            norm_psi1 = psi_1.norm()
            #print('norm_psi1 at timestep {} :'.format(norm_psi1, i))
             
            delta_p = 1 - norm_psi1 ** 2
            
            if r1 > delta_p: #evolve with non-hermitian hamiltonian
                psi_t = psi_1.copy()
            
            elif r1 <= delta_p: #select a lindblad operator and perform a jump
                print( 'jumping at timestep {}'.format(i) )
                dt1, n_iterations, unconverged = self.bisection(self.norm_decrease(psi_t, r1, dt),0,dt,tol,max_iterations,0)
                #unconverged_counter += unconverged
                #n_iterations_counter[i] = n_iterations
                #evolve up to t + dt1
                self.conf_tdvp.dt = dt1
                self.conf_tdvp.trunc.threshold = threshold * psi_t.norm()
                self.conf_tdvp.trunc.weight = weight * psi_t.norm() **2 
                self.conf_tdvp.trunc.maxStates = int( maxStates * psi_t.norm() **2 )
                worker = ptn.mp.tdvp.PTDVP( psi_t.copy(),[self.H_eff.copy()], self.conf_tdvp.copy() ) 
                worker_do_stepList = worker.do_step()
                psi_before = worker.get_psi(False)
                #jump at dt1
                psi_t, which_jump_op  = self.select_jump_operator( psi_before, r2_array[i], threshold, weight, maxStates )   #FIXME UNCOMMENT   
                #evolve from dt1 to dt
                dt2 = dt-dt1
                self.conf_tdvp.dt = dt2
                self.conf_tdvp.trunc.threshold = threshold * psi_t.norm()
                self.conf_tdvp.trunc.weight = weight * psi_t.norm() **2 
                self.conf_tdvp.trunc.maxStates = int( maxStates * psi_t.norm() **2 )
                worker = ptn.mp.tdvp.PTDVP( psi_t.copy(),[self.H_eff.copy()], self.conf_tdvp.copy() ) 
                worker_do_stepList = worker.do_step()
                psi_t = worker.get_psi(False)
                                
                jump_counter +=1 #debugging
                jump_time_list.append(i) #FIXME: return this!
                np.savetxt('jump_time_list',jump_time_list)
                #print('state after jump: ',psi_t)
                psi_t.normalise() #NOTE: normalize only if jump occurs
                r1 = r1_array[i] #NOTE: change random number only if jump occurs
                
                #reset correct timestep and correct, normalized initial state for next step

                self.conf_tdvp.dt = dt
                self.conf_tdvp.trunc.threshold = threshold * psi_t.norm()
                self.conf_tdvp.trunc.weight = weight * psi_t.norm() **2 
                self.conf_tdvp.trunc.maxStates = int( maxStates * psi_t.norm() **2 )
                worker = ptn.mp.tdvp.PTDVP( psi_t.copy(),[self.H_eff.copy()], self.conf_tdvp.copy() ) #NOTE: reinitialize worker only if jump occurs

            #Compute observables
            #t_obs_start = time.process_time()
            #FIXME: check wheter syten normalizes automatically when computing observables!
            obsdict.compute_all_observables_at_one_timestep(psi_t, i+1) 
            #print('process time for observables at timest {}: {}'.format(i, time.process_time() - t_obs_start) )
        os.chdir('..') #exit the trajectory directory
        #print('jump_counter: ',jump_counter)    
            
        
        
